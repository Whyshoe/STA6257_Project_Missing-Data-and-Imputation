<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.542">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vyshnavi">
<meta name="dcterms.date" content="2024-02-12">

<title>index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Missing Data and Imputations - Data Science Capstone</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Vyshnavi </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 12, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><strong><em>Literature Review - Week 5</em></strong></p>
<p>Missing Data and Imputations</p>
<p>Introduction: What is “Missing Data”? Missing data refers to the absence of values for certain observations or variables in a dataset. When collecting or recording data, it is not uncommon to encounter situations where information is not available for every individual or specific variable. Missing data can occur for various reasons, such as non-response by participants, data entry errors, equipment malfunctions, or simply because certain information was not collected. There are three main types of missing data: 1. Missing Completely at Random (MCAR): The missingness of data is unrelated to both observed and unobserved variables. In other words, the probability of data being missing is the same for all observations. 2. Missing at Random (MAR): The missingness is related to observed variables but not to the values of the missing data itself. In this case, the probability of data being missing can be predicted by other variables in the dataset. 3. Missing Not at Random (MNAR): The missingness is related to the values of the missing data itself, even after considering observed variables. This type of missing data can introduce bias and is often more challenging to handle. Handling missing data is crucial in statistical analysis because it can lead to biased or inefficient results if not addressed properly. Researchers employ various techniques, such as imputation methods, to estimate or replace the missing values and ensure the validity and reliability of their analyses. Imputation involves filling in missing values with plausible estimates based on the observed data or using statistical models to predict missing values. Researchers need to be aware of the nature and mechanisms of missing data in their datasets, as the choice of imputation method depends on these factors. Ignoring missing data or handling it incorrectly can impact the accuracy and generalizability of study findings. Imputation in R-language: Imputation is the process of estimating or replacing missing values in a dataset with possible substitutes. R, a programming language and environment for statistical computing and graphics, provides various tools and packages for imputing missing data. Imputation methods in R aim to fill in the missing values using statistical techniques, ensuring that the dataset remains suitable for analysis.</p>
<p>SCOPE OF OUR PROJECT: 1. Understanding the Importance of Handling Missing Data: - Missing data is a prevalent issue in datasets, and its improper handling can lead to biased and unreliable results. Recognizing the impact of missing data on statistical analyses is crucial for producing accurate and meaningful insights. 2. Diverse Imputation Methods in R: - R-Language offers a rich set of tools and packages for imputing missing data. The project explored diverse methods, including mean/median imputation, multiple imputation, k-nearest neighbors, random forest, and rule-based techniques. Each method comes with its advantages and limitations, emphasizing the importance of selecting an appropriate approach based on the dataset characteristics. 3. Practical Implementation in R: - The project demonstrated the practical implementation of various imputation methods using R. Through hands-on examples and code snippets, the project showcased how to use packages like <code>mice</code>, <code>missForest</code>, and other built-in functions to impute missing values. 4. Consideration of Assumptions and Limitations: - Each imputation method relies on certain assumptions, and understanding these assumptions is crucial for making informed choices. Additionally, it is essential to acknowledge the limitations of each method and consider the potential impact on the validity of results. 5. Future Directions and Emerging Trends: - The project touched upon emerging trends in missing data imputation, such as Bayesian approaches and the integration of machine learning techniques. Recognizing the evolving landscape of imputation methods allows for staying at the forefront of advancements in the field. 6. Best Practices and Recommendations: - The project outlined best practices for handling missing data, emphasizing the importance of careful consideration of the missing data mechanism, validation of imputation results, and sensitivity analysis. These practices contribute to the reliability and robustness of statistical analyses. 7. User-Friendly Implementation in R: - R-Language, with its extensive libraries and user-friendly syntax, proved to be a powerful tool for implementing missing data imputation methods. The project highlighted the ease with which researchers can leverage R for handling missing data in their analyses.</p>
<p>Related work: When undertaking a project on any topic, it’s essential to explore existing research to build a strong foundation and understand the current state of the field. Here are some key references and related works on our project: 1. “Statistical Analysis with Missing Data” by Roderick J. A. Little and Donald B. Rubin (2002): - This seminal work provides a comprehensive overview of statistical methods for handling missing data. It covers fundamental concepts, challenges, and various imputation techniques. 2. “Multiple Imputation for Nonresponse in Surveys” by Donald B. Rubin (1987): - Rubin’s work on multiple imputation is crucial for understanding the theoretical foundations of this approach. The book delves into the statistical theory behind multiple imputation and its application in survey research. 3. “Flexible Imputation of Missing Data” by Stef van Buuren (2018): - This book focuses on the <code>mice</code> package in R and its application for multiple imputation. It provides practical insights into handling missing data and implementing imputation methods using R. 4. “Handbook of Statistical Methods for Missing Data” edited by Enders, Craig K., and Joseph F. Halcon (2012): - This handbook is a comprehensive resource covering various statistical methods for handling missing data. It includes contributions from multiple authors, offering a diverse perspective on the topic. 5. “Missing Data: A Gentle Introduction” by Patrick E. McKnight, Katherine M. McKnight, and Soonhwa Seok (2007): - This introductory book provides a gentle and accessible introduction to missing data concepts, challenges, and common imputation techniques. It’s suitable for those new to the field. 6. “missForest: Nonparametric Missing Value Imputation using Random Forest” by Stekhoven, Daniel J., and Peter Bühlmann (2012): - The paper introduces the <code>missForest</code> package in R, which uses a random forest algorithm for imputation. It is a valuable reference for understanding and implementing this specific imputation method. 7. “Imputation of Missing Values in Longitudinal Data: A Comparison of Modern Techniques” by Allison et al.&nbsp;(2012): - This research paper compares different imputation techniques, including multiple imputation, for handling missing values in longitudinal data. It provides insights into the performance of various methods.</p>
<p>METHODS and APPLICATIONS: Common Imputation Methods in R: 1. Mean/Median Imputation: - Replace missing values with the mean or median of the observed values in the variable. - <code>mean()</code> and <code>median()</code> functions in R can be used for this method. 2. Multiple Imputation: - Generate multiple sets of plausible values for each missing data point, considering the uncertainty associated with imputation. - The <code>mice</code> (Multivariate Imputation by Chained Equations) package in R is commonly used for multiple imputation. 3. K-Nearest Neighbors (KNN) Imputation: - Impute missing values based on the values of their nearest neighbors in the dataset. - The <code>impute.knn()</code> function in the <code>impute</code> package is a popular choice for KNN imputation. 4. Expectation-Maximization (EM) Algorithm: - An iterative algorithm that estimates missing values based on the observed data. - Implemented in R through functions like <code>EM()</code> in the <code>mixtools</code> package. 5. Random Forest Imputation: - Utilize a random forest algorithm to predict missing values based on other variables. - The <code>missForest</code> package provides an implementation of this method. 6. Next or Previous Value: - Method: Replace missing values with the next or previous observed value in the dataset. - Application: Suitable for time-series data where missing values are expected to follow a temporal pattern. 7. K Nearest Neighbors (KNN): - Method: Impute missing values by averaging or using the majority vote of the (k) nearest neighbors in the feature space. - Application: Effective for imputing values based on similarities in multivariate space. 8. Maximum or Minimum Value: - Method: Replace missing values with the maximum or minimum observed value in the variable. - Application: Simple imputation method when the assumption is that missing values are extreme values. 9. Missing Value Prediction: - Method: Predict missing values using statistical models or machine learning algorithms. - Application: Useful when there is a complex relationship between variables, and predictions can be made based on the observed data. 10. Most Frequent Value: - Method: Replace missing values with the most frequently occurring value in the variable. - Application: Appropriate for categorical variables or when missing values are likely to be the mode. 11. Average or Linear Interpolation: - Method: Impute missing values by taking the average of adjacent values or using linear interpolation. - Application: Common for time-series data where a linear relationship between observations is assumed. 12. (Rounded) Mean or Moving Average or Median Value: - Method: Impute missing values with the mean, median, or moving average of observed values. - Application: Suitable for imputing missing values when the variable exhibits a stable trend over time. 13. Fixed Value: - Method: Replace missing values with a predetermined fixed value. - Application: Used when a constant value is deemed appropriate for imputation. 14. Rule-based Imputation Technique: - Method: Apply predefined rules or logic to impute missing values based on the characteristics of the dataset. - Application: Customized imputation based on domain knowledge or specific data patterns. 15. Random Forest: - Method: Utilize a random forest algorithm to predict missing values based on other variables in the dataset. - Application: Effective for complex relationships and interactions between variables, often providing accurate imputations. These methods offer different approaches to handling missing data, and the choice of method depends on the characteristics of the dataset and the assumptions about the missing data mechanism. It’s crucial to carefully consider the context and nature of the data when selecting an imputation technique. FORMULAE FOR EACH METHOD: 1. Mean/Median Imputation: - Mean Imputation: ({X} = ) - Median Imputation: (M = (X_1, X_2, …, X_n)) In both cases, missing values are replaced with the mean or median of the observed values in the variable (X). 2. Multiple Imputation: - The multiple imputation process involves three steps: a) Imputation (m times): Generate (m) imputed datasets, where missing values are filled using a specified imputation method. b) Analysis (m times): Analyze each imputed dataset separately using the desired statistical analysis. c) Pooling: Combine the results from the (m) analyses to obtain final estimates and standard errors. The imputation step often involves drawing imputed values from a predictive distribution based on observed data. 3. K-Nearest Neighbors (KNN) Imputation: - For each missing value (X_{}) in a variable (X): [X_{} = <em>{i=1}^{k} X_i] - Where (X_i) represents the observed values of the (k) nearest neighbors to the missing value. 4. Expectation-Maximization (EM) Algorithm: - The EM algorithm iteratively estimates missing values using two steps: 1. Expectation (E-step): Compute the expected value of the missing data given the observed data and current parameter estimates. 2. Maximization (M-step): Update the parameter estimates to maximize the expected log-likelihood. The algorithm repeats these steps until convergence. 5. Random Forest Imputation: - Random Forest imputation involves training a Random Forest model using observed data to predict missing values. The exact formula is complex and involves the aggregation of predictions from multiple decision trees in the Random Forest. The imputed value is often the average (regression) or majority vote (classification) of the individual tree predictions. 6. Next or Previous Value: - Impute the missing value with the next or previous observed value in the time series. - Formula: (X</em>{} = X_{}) (next or previous value) 7. K Nearest Neighbors (KNN): - Impute missing values based on the values of their (k) nearest neighbors. - Formula: (X_{} = <em>{i=1}^{k} X_i) 8. Maximum or Minimum Value: - Impute the missing value with the maximum or minimum observed value in the variable. - Formula: (X</em>{} = (X_{})) or (X_{} = (X_{})) 9. Missing Value Prediction: - Predict missing values using a regression model based on other observed variables. - Formula: Depends on the specific regression model used for prediction. 10. Most Frequent Value: - Impute the missing value with the most frequently observed value in the variable. - Formula: (X_{} = (X_{})) 11. Average or Linear Interpolation: - Impute missing values using the average or linear interpolation between adjacent observed values. - Formula: (X_{} = (X_{} + X_{})) 12. (Rounded) Mean or Moving Average or Median Value: - Impute missing values with the rounded mean, moving average, or median of observed values. - Formula: Depends on the specific method used for rounding or calculating the mean, moving average, or median. 13. Fixed Value: - Impute missing values with a predefined fixed value. - Formula: (X_{} = ) 14. Rule-based Imputation Technique: - Impute missing values based on predefined rules or conditions. - Formula: Depends on the specific rules or conditions defined for imputation. 15. Random Forest: - Utilize a random forest algorithm to predict missing values based on other variables. - Formula: The exact formula involves the aggregation of predictions from multiple decision trees in the Random Forest. The imputed value is often the average (regression) or majority vote (classification) of the individual tree predictions. These formulas provide a high-level overview of the imputation methods. However, the specific details may vary depending on the software implementation and the underlying statistical models used. For a more detailed understanding, it is recommended to refer to the original papers and documentation of the respective methods and packages.</p>
<p>CONCLUSION: In conclusion, the project on missing data and imputation using R-Language has provided a thorough exploration of diverse techniques for handling missing values. By delving into methods such as mean/median imputation, multiple imputation, k-nearest neighbors, and random forest, we have gained a nuanced understanding of their applications and limitations. The practical implementation in R demonstrated the accessibility of these methods, showcasing the importance of selecting an approach aligned with data characteristics. Emphasizing best practices, such as sensitivity analysis and validation, ensures the reliability of imputation results. This project not only equips researchers with practical skills for addressing missing data but also highlights the dynamic landscape of emerging trends, positioning them at the forefront of advancements in the field. Overall, the use of R-Language for missing data imputation underscores its effectiveness and user-friendly nature in facilitating robust statistical analyses.</p>
<p>SUMMARIES OF MY PAPERS: 1. An R function for imputation of missing cells in two-way data sets by EM-AMMI algorithm J Paderewski Link: https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C10&amp;q=An+R+function+for+imputation+of+missing+cells&amp;btnG=</p>
<p>Goal of the paper The paper delivers a R function for imputing missing values in two-way classification data sets, with a special focus on agricultural trials. The major purpose is to create a tool, the EM-AMMI algorithm, for imputing missing cells in datasets used for genotype-by-environment agricultural science studies. The significance stems from the frequent occurrence of missing data in agricultural experiments, as well as the requirement for trustworthy imputation methods to ensure the integrity of statistical studies. Methods: The paper employs the Expectation-Maximization AMMI (EM-AMMI) algorithm for imputing missing values in two-way data. The algorithm proceeds by estimating the parameters of the AMMI model, calculating adjusted means based on the model, filling in missing cells with these adjusted means, and iterating until convergence. The function allows users to specify the number of principal components and initial values for missing cells. Additionally, a repeatability check function is proposed to evaluate the reliability of the imputation, especially crucial for small datasets. Results/Limitations: The results demonstrate the effectiveness of the EM-AMMI algorithm in imputing missing values in agricultural trials, offering a practical solution for datasets with incomplete information. The function provides key output metrics such as the imputed matrix, sum of squares for principal components, iteration count, precision of convergence, and the number of principal components used. However, the paper acknowledges limitations, particularly the sensitivity of results to the initial values of missing cells, especially when the chosen number of principal components is excessive. The proposed repeatability check function helps address this issue by assessing the consistency of results across multiple runs. Conclusion: In conclusion, the paper addresses a crucial need in crop science research by providing a robust tool for imputing missing values in genotype-by-environment trials. The EM-AMMI algorithm, implemented as an R function, offers a valuable contribution to the field, facilitating reliable statistical analyses even in the presence of missing data. The proposed repeatability check enhances the confidence in the imputation process, making it a valuable resource for researchers dealing with incomplete datasets in agricultural trials.</p>
<ol start="2" type="1">
<li>Missing value imputation approach for mass spectrometry-based metabolomics data R Wei, J Wang, M Su, E Jia, S Chen, T Chen, Y Ni Link: https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C10&amp;q=Missing+value+imputation+approach+for+mass+spectrometry+based+metabolomics+&amp;btnG=</li>
</ol>
<p>Goal of the paper: The paper addresses the prevalent issue of missing values in mass-spectrometry (MS) based metabolomics data. The goal is to comprehensively compare and evaluate eight imputation methods (zero, half minimum (HM), mean, median, random forest (RF), singular value decomposition (SVD), k-nearest neighbors (kNN), and quantile regression imputation of left-censored data (QRILC)) for different types of missing values (missing not at random (MNAR), missing at random (MAR), and missing completely at random (MCAR)) using four metabolomics datasets. The study aims to provide insights into the performance of these methods under various conditions. Importance: Handling missing values in metabolomics data is crucial due to the inherent complexity of data acquisition, where certain compounds might not be identified or quantified in some samples. The selection of imputation methods significantly influences subsequent data analyses. The paper underscores the need for a systematic evaluation to guide researchers in choosing appropriate imputation methods based on the nature of missing values, ultimately enhancing the reliability of metabolomics studies. Methods: The paper employs a rigorous evaluation approach, comparing eight imputation methods across different types of missing values using metrics such as normalized root mean squared error (NRMSE), NRMSE-based sum of ranks (SOR), principal component analysis (PCA)/partial least squares (PLS)-Procrustes analysis, Student’s t-test, and correlation analysis. The imputation methods include established techniques like RF, kNN, and SVD, as well as specialized methods like QRILC for left-censored MNAR situations. Results/Limitations: The results highlight that RF performs best for MCAR/MAR situations, while QRILC is favored for left-censored MNAR. However, the study acknowledges that imputation performance decreases with an increasing number of missing values. Limitations include the sensitivity of imputation methods to the nature and extent of missing data. The paper emphasizes the need for a comprehensive strategy, proposing a web-tool (https://metabolomics.cc.hawaii.edu/software/MetImp/) to assist researchers in choosing and applying suitable imputation methods.</p>
<p>In conclusion, the paper contributes valuable insights into the selection of imputation methods for missing values in metabolomics data, offering practical recommendations and tools to enhance the accuracy and reliability of data analyses in this critical domain.</p>
<ol start="3" type="1">
<li>Dealing with missing data in a multi-question depression scale: a comparison of imputation methods ###FM Shrive, H Stuart, H Quan, WA Ghali - BMC medical research …, 2006 – Springer### Goal of the Paper: The goal of this paper is to address the challenge of missing data in research projects, particularly in studies using self-report scales, with a focus on the Zung Self-reported Depression scale (SDS). The paper aims to compare and evaluate six different imputation techniques for handling missing data in the SDS. The overarching objective is to provide insights into the effectiveness of various imputation methods in different missing data scenarios, considering factors such as validity, ease of interpretability, and statistical expertise. Methods: The study involves 1580 participants from a surgical outcomes study who completed the SDS, a 20-question scale assessing depressive symptoms. Missing values are simulated using three scenarios: missing completely at random (MCAR), missing at random (MAR), and missing not at random (MNAR). Six imputation techniques are compared: multiple imputation, single regression, individual mean, overall mean, participant’s preceding response, and random selection. The evaluation involves comparing imputed mean SDS scores, standard deviations, Spearman correlation coefficient, percent misclassified, and the Kappa statistic against population statistics. Results: - Imputation Methods Evaluation (10% Missing): Multiple imputation (MI) stands out with the highest Kappa statistic (0.89), indicating ‘near perfect’ agreement. Single regression and individual mean imputation also yield favorable results. Random selection performs less well. - Effect of Increasing Missing Data (20%, 30%): MI maintains high Kappa statistics even as the percent of missing information increases. Individual mean and single regression show substantial agreement but with a slight decrease. Other methods exhibit declines in performance. - Unbalanced Missing Data Scenarios: MI generally performs well, but individual mean outperforms MI in some unbalanced scenarios. Conclusion: The paper concludes that multiple imputation is the most accurate method for handling missing data in most scenarios assessed for the SDS. Individual mean imputation, a simpler approach, is also deemed appropriate, demonstrating comparable accuracy and interpretability. The authors emphasize the importance of considering methodological assessments when confronted with missing data, suggesting a balance between validity, interpretability, and the expertise of the research team in selecting the optimal imputation method.</li>
<li>Dealing with missing data in a multi-question depression scale: a comparison of imputation methods ###FM Shrive, H Stuart, H Quan, WA Ghali, BMC medical research methodology, 2006•Springer*** Goal of the Paper: The goal of the paper is to address the crucial issue of missing data in machine learning and data mining. The authors emphasize the significance of data quality in these fields and highlight the challenges posed by missing values, which can lead to biased results in knowledge discovery. The paper aims to introduce and implement an imputation approach using the IBK (k-Nearest Neighbors) classification algorithm to handle missing values in a dataset. Methods: 1. Introduction: The paper begins by discussing the importance of data quality in machine learning and data mining, with a focus on handling missing values. 2. Background: The background section provides an overview of data mining, preprocessing techniques, missing values, and imputation methods, particularly focusing on the K-Nearest Neighbors (KNN) algorithm for imputation. 3. Related Work: The authors review related work on missing data imputation, discussing different approaches and their applications. 4. Experimental Procedures: The paper outlines the experimental procedures, including the dataset used (from Juba Insurance &amp; Reinsurance Company), the introduction of artificial missing values, and the proposed imputation method using the IBK algorithm. Results: The authors implement the proposed IBK imputation algorithm using the k-NN approach to handle missing values in the dataset. They demonstrate the process step-by-step, including data preprocessing, normalization, imputation, and analysis of the imputed dataset. The results are presented using visualizations, summary statistics, and a comparison between the original and imputed datasets. Conclusion: The paper concludes by summarizing the achieved results and the effectiveness of the proposed imputation approach. The authors emphasize the importance of data accuracy in knowledge discovery and suggest that the presented method can contribute to improving the quality of datasets used in machine learning and data mining. They also discuss potential future directions, such as exploring larger datasets and investigating missingness mechanisms automatically. In essence, the paper addresses the challenge of missing data in the context of machine learning and data mining, proposing a specific imputation method using the IBK classification algorithm.</li>
</ol>
<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">Introduction</h3>
<p><strong><em>Assignment: 4 </em></strong></p>
<p><strong><em>Dealing with missing data in a multi-question depression scale: a comparison of imputation methods</em></strong> ###FM Shrive, H Stuart, H Quan, WA Ghali - BMC medical research …, 2006 – Springer###</p>
<p><strong><em>Goal of the Paper:</em></strong> The goal of this paper is to address the challenge of missing data in research projects, particularly in studies using self-report scales, with a focus on the Zung Self-reported Depression scale (SDS). The paper aims to compare and evaluate six different imputation techniques for handling missing data in the SDS. The overarching objective is to provide insights into the effectiveness of various imputation methods in different missing data scenarios, considering factors such as validity, ease of interpretability, and statistical expertise.</p>
<p><strong><em>Methods:</em></strong> The study involves 1580 participants from a surgical outcomes study who completed the SDS, a 20-question scale assessing depressive symptoms. Missing values are simulated using three scenarios: missing completely at random (MCAR), missing at random (MAR), and missing not at random (MNAR). Six imputation techniques are compared: multiple imputation, single regression, individual mean, overall mean, participant’s preceding response, and random selection. The evaluation involves comparing imputed mean SDS scores, standard deviations, Spearman correlation coefficient, percent misclassified, and the Kappa statistic against population statistics.</p>
<p><strong><em>Results:</em></strong> - Imputation Methods Evaluation (10% Missing): Multiple imputation (MI) stands out with the highest Kappa statistic (0.89), indicating ‘near perfect’ agreement. Single regression and individual mean imputation also yield favorable results. Random selection performs less well. - Effect of Increasing Missing Data (20%, 30%): MI maintains high Kappa statistics even as the percent of missing information increases. Individual mean and single regression show substantial agreement but with a slight decrease. Other methods exhibit declines in performance. - Unbalanced Missing Data Scenarios: MI generally performs well, but individual mean outperforms MI in some unbalanced scenarios.</p>
<p><strong><em>Conclusion:</em></strong> The paper concludes that multiple imputation is the most accurate method for handling missing data in most scenarios assessed for the SDS. Individual mean imputation, a simpler approach, is also deemed appropriate, demonstrating comparable accuracy and interpretability. The authors emphasize the importance of considering methodological assessments when confronted with missing data, suggesting a balance between validity, interpretability, and the expertise of the research team in selecting the optimal imputation method.</p>
<p><strong><em>Dealing with missing data in a multi-question depression scale: a comparison of imputation methods</em></strong> ###FM Shrive, H Stuart, H Quan, WA Ghali, BMC medical research methodology, 2006•Springer***</p>
<p><strong><em>Goal of the Paper:</em></strong> The goal of the paper is to address the crucial issue of missing data in machine learning and data mining. The authors emphasize the significance of data quality in these fields and highlight the challenges posed by missing values, which can lead to biased results in knowledge discovery. The paper aims to introduce and implement an imputation approach using the IBK (k-Nearest Neighbors) classification algorithm to handle missing values in a dataset.</p>
<p><strong><em>Methods:</em></strong> 1. Introduction: The paper begins by discussing the importance of data quality in machine learning and data mining, with a focus on handling missing values. 2. Background: The background section provides an overview of data mining, preprocessing techniques, missing values, and imputation methods, particularly focusing on the K-Nearest Neighbors (KNN) algorithm for imputation. 3. Related Work: The authors review related work on missing data imputation, discussing different approaches and their applications. 4. Experimental Procedures: The paper outlines the experimental procedures, including the dataset used (from Juba Insurance &amp; Reinsurance Company), the introduction of artificial missing values, and the proposed imputation method using the IBK algorithm.</p>
<p><strong><em>Results:</em></strong> The authors implement the proposed IBK imputation algorithm using the k-NN approach to handle missing values in the dataset. They demonstrate the process step-by-step, including data preprocessing, normalization, imputation, and analysis of the imputed dataset. The results are presented using visualizations, summary statistics, and a comparison between the original and imputed datasets.</p>
<p><strong><em>Conclusion:</em></strong> The paper concludes by summarizing the achieved results and the effectiveness of the proposed imputation approach. The authors emphasize the importance of data accuracy in knowledge discovery and suggest that the presented method can contribute to improving the quality of datasets used in machine learning and data mining. They also discuss potential future directions, such as exploring larger datasets and investigating missingness mechanisms automatically. In essence, the paper addresses the challenge of missing data in the context of machine learning and data mining, proposing a specific imputation method using the IBK classification algorithm.</p>
</section>
<section id="what-is-method" class="level3">
<h3 class="anchored" data-anchor-id="what-is-method">What is “method”?</h3>
<p>This is an introduction to Kernel regression, which is a non-parametric estimator that estimates the conditional expectation of two variables which is random. The goal of a kernel regression is to discover the non-linear relationship between two random variables. To discover the non-linear relationship, kernel estimator or kernel smoothing is the main method to estimate the curve for non-parametric statistics. In kernel estimator, weight function is known as kernel function <span class="citation" data-cites="efr2008">[@efr2008]</span>. Cite this paper <span class="citation" data-cites="bro2014principal">[@bro2014principal]</span>. The GEE <span class="citation" data-cites="wang2014">[@wang2014]</span>.</p>
<p>This is my work and I want to add more work…</p>
</section>
<section id="related-work" class="level3">
<h3 class="anchored" data-anchor-id="related-work">Related work</h3>
<p>This section is going to cover the literature review…</p>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<p>The common non-parametric regression model is <span class="math inline">\(Y_i = m(X_i) + \varepsilon_i\)</span>, where <span class="math inline">\(Y_i\)</span> can be defined as the sum of the regression function value <span class="math inline">\(m(x)\)</span> for <span class="math inline">\(X_i\)</span>. Here <span class="math inline">\(m(x)\)</span> is unknown and <span class="math inline">\(\varepsilon_i\)</span> some errors. With the help of this definition, we can create the estimation for local averaging i.e.&nbsp;<span class="math inline">\(m(x)\)</span> can be estimated with the product of <span class="math inline">\(Y_i\)</span> average and <span class="math inline">\(X_i\)</span> is near to <span class="math inline">\(x\)</span>. In other words, this means that we are discovering the line through the data points with the help of surrounding data points. The estimation formula is printed below <span class="citation" data-cites="R-base">[@R-base]</span>:</p>
<p><span class="math display">\[
M_n(x) = \sum_{i=1}^{n} W_n (X_i) Y_i  \tag{1}
\]</span> <span class="math inline">\(W_n(x)\)</span> is the sum of weights that belongs to all real numbers. Weights are positive numbers and small if <span class="math inline">\(X_i\)</span> is far from <span class="math inline">\(x\)</span>.</p>
<p>Another equation:</p>
<p><span class="math display">\[
y_i = \beta_0 + \beta_1 X_1 +\varepsilon_i
\]</span></p>
</section>
<section id="analysis-and-results" class="level2">
<h2 class="anchored" data-anchor-id="analysis-and-results">Analysis and Results</h2>
<section id="data-and-visualization" class="level3">
<h3 class="anchored" data-anchor-id="data-and-visualization">Data and Visualization</h3>
<p>A study was conducted to determine how…</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># loading packages </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggthemes)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggrepel)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dslabs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load Data</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kable</span>(<span class="fu">head</span>(murders))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<table class="table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: left;">state</th>
<th style="text-align: left;">abb</th>
<th style="text-align: left;">region</th>
<th style="text-align: right;">population</th>
<th style="text-align: right;">total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Alabama</td>
<td style="text-align: left;">AL</td>
<td style="text-align: left;">South</td>
<td style="text-align: right;">4779736</td>
<td style="text-align: right;">135</td>
</tr>
<tr class="even">
<td style="text-align: left;">Alaska</td>
<td style="text-align: left;">AK</td>
<td style="text-align: left;">West</td>
<td style="text-align: right;">710231</td>
<td style="text-align: right;">19</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Arizona</td>
<td style="text-align: left;">AZ</td>
<td style="text-align: left;">West</td>
<td style="text-align: right;">6392017</td>
<td style="text-align: right;">232</td>
</tr>
<tr class="even">
<td style="text-align: left;">Arkansas</td>
<td style="text-align: left;">AR</td>
<td style="text-align: left;">South</td>
<td style="text-align: right;">2915918</td>
<td style="text-align: right;">93</td>
</tr>
<tr class="odd">
<td style="text-align: left;">California</td>
<td style="text-align: left;">CA</td>
<td style="text-align: left;">West</td>
<td style="text-align: right;">37253956</td>
<td style="text-align: right;">1257</td>
</tr>
<tr class="even">
<td style="text-align: left;">Colorado</td>
<td style="text-align: left;">CO</td>
<td style="text-align: left;">West</td>
<td style="text-align: right;">5029196</td>
<td style="text-align: right;">65</td>
</tr>
</tbody>
</table>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ggplot1 <span class="ot">=</span> murders <span class="sc">%&gt;%</span> <span class="fu">ggplot</span>(<span class="at">mapping =</span> <span class="fu">aes</span>(<span class="at">x=</span>population<span class="sc">/</span><span class="dv">10</span><span class="sc">^</span><span class="dv">6</span>, <span class="at">y=</span>total)) </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  ggplot1 <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">col=</span>region), <span class="at">size =</span> <span class="dv">4</span>) <span class="sc">+</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_text_repel</span>(<span class="fu">aes</span>(<span class="at">label=</span>abb)) <span class="sc">+</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>() <span class="sc">+</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_y_log10</span>() <span class="sc">+</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_smooth</span>(<span class="at">formula =</span> <span class="st">"y~x"</span>, <span class="at">method=</span>lm,<span class="at">se =</span> F)<span class="sc">+</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Populations in millions (log10 scale)"</span>) <span class="sc">+</span> </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">"Total number of murders (log10 scale)"</span>) <span class="sc">+</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggtitle</span>(<span class="st">"US Gun Murders in 2010"</span>) <span class="sc">+</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name =</span> <span class="st">"Region"</span>)<span class="sc">+</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="statistical-modeling" class="level3">
<h3 class="anchored" data-anchor-id="statistical-modeling">Statistical Modeling</h3>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
</section>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>